#DEF ScreenAddress 0xa000

Main:
	ST 0b0000011111100000 $CursorFG 
	ST 0 $CursorPosX
	ST 0 $CursorPosY
	LD R0 String
	CALL PrintString
	
	
	ST 0b1111100000000000 $CursorFG 
	ST 0 $CursorPosX
	ST 120 $CursorPosY
	LD R0 String2
	CALL PrintString
	HLT


PrintString:
	PSH
	PrintStringLoop:
		DD R0
		LD R1 ; Get the character
		CZ R1
		JMPC PrintStringExit
		CALL PrintChar
		INC R0
		
		LD R2 $CursorPosX
		ADD R2 8
		CL R2 128 ; <
		JMPC PrintStringDoneCheck

		LD R2 $CursorPosY
		ADD R2 8
		ST R2 $CursorPosY
		LD R2 0
		
		PrintStringDoneCheck:
		ST R2 $CursorPosX
		JMP PrintStringLoop


	PrintStringExit:
	POP
	RET


; R1 is the character
PrintChar:
	PSH

	SUB R1 ' ' ; Offset to space, skipping control codes
	SHL R1 2 ; Multiply by 4 because each font character takes 4 bytes

	ADD R1 Font ; Offset the character to where the font is mapped in ascii
	;;;;;;
	;; R0: Byte data in the font (Bool for writing)
	;; R1: Address within the font (Scanner)
	;; R2: Screen address
	;; R3: Vertical counter (Cursor color)
	;;;;;;

	; Screen address offset
	LD R2 $CursorPosY
	SHL R2 7
	ADD R2 $CursorPosX
	ADD R2 ScreenAddress
	; ---
	LD R3 0
	
	DD R1 ; Go to the address within the font
	PSH R1
	LD R0 ; Load the first byte of the font character
	PSH R0
	LD R1 0 ; Initialize 'scanner' to 0
	PrintCharLoop:
		PrintCharLoopRow:
			POP R0
			PSH R0
			CALL isolateBit
			; R0 now has a 1 or 0 for the pixel value at the first bit in the font
			CZ R0
			JMPC PrintCharSkipDraw

			DD R2
			PSH R3
			LD R3 $CursorFG
			ST R3
			POP R3


			PrintCharSkipDraw:
			INC R1
			INC R2
			PSH R1
			AND R1 0b111
			CNZ R1
			POP R1
			JMPC PrintCharLoopRow
			ADD R2 120
			POP R0
			INC R0
			
			
			PSH R3
			AND R3 1
			CZ R3
			POP R3
			POP R1
			JMPC PrintCharDontUpdateColumn
			
			INC R1
			DD R1
			PSH R1
			LD R1 0
			
			JMP PrintCharDontUpdateColumnEnd
			
			PrintCharDontUpdateColumn:
			DD R1
			PSH R1
			LD R1 8
			
			PrintCharDontUpdateColumnEnd:
			
			INC R3
			CNE R3 8
			
			LD R0
			PSH R0
			JMPC PrintCharLoop

		

	PrintCharLoopEnd:
	POP R0
	POP R1
	POP
	RET


; R0 is the value to scan, R1 is the bit to scan
; Returned is R0 with either 1 or 0
isolateBit:
	SHL0 R1
	SHR R0 0x000f
	RET


CursorFG: .db 0b1111100000000000

CursorPosX: .dd 0
CursorPosY: .dd 0

String:
.ds "Hi Mason! This  "
.ds "is a 602 byte   "
.ds "program to draw "
.ds "this string...  "
.dd 0

String2:
.ds "-Send Help Soon-"
.dd 0


Font:
#INC font.hex
